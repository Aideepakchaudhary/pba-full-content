## Parachains

Lecture 5, Module 4

Instructor: Bernhard Schuster, Robert Klotzner

<hr>

### Lecture Goals

- General blockchain challenges
- Parachain consensus
- Valid/invalid parachain blocks
---

## Blockchain Challenges

- Performance
- Scalability
- Security
- Liveness
- Decentralization

Note:

Scalability: In every aspect: Throughput, but also storage. Relay chain
validators are light clients to parachains. Parachains act as heterogenous
shards, both in terms of execution and data availablity. In contrast to Ethereum
2, which will just offer sharded data availability.

Performance via Specialization: Parachains operate independently via "collator" nodes, can do
whatever they want, as long as the provide a PoV to relay chain validators.
Relay chain validators don't have to bother about handling transaction pools and
such.

---

## How to achieve scalability?

- Split the work
<!-- .element: class="fragment" -->
- But maintain security
<!-- .element: class="fragment" -->
- Lifeness?
<!-- .element: class="fragment" -->

Note:

Security: Defer solution to upcoming slides.
Lifeness: Suggest rotation.

---

## Suggested Architecture

TODO: Picture of grouped validators validating parachains and collator nodes
connecting, keeping storage for the parachain, handling transaction pools +
transaction gossip. Hint rotating groups via arrows.

Note:

Idea: Visualize how performance and scalability is achieved. For example that
collators are responsible to keep state for the parachains, take care of lots of
the nitty-gritty details of block production. Validators don't have to worry
about individual transactions, collecting & prioritizing them, keeping them in
pools.

In Eth 2 version 1 nomenclature: Collators/Parachain provide shards for data availability,
but also version 2 execution shards.

<!-- -->

---

## All good?

- Bad group?
<!-- .element: class="fragment" -->
- Large groups?
<!-- .element: class="fragment" -->
- Performance
<!-- .element: class="fragment" -->
- Lifeness
<!-- .element: class="fragment" -->

Note:

Large group: Make it statistically unlikely enough to have a majority malicious
group. Works, but:

-> Performance: relying on statistics: groups have to be relatively large ~40 validators.
-> Lifeness: If nodes don't vote we have to assume the worst -> escalate.


---

## Catch Bad Guys

---

## Wait .. Bad Guy?

What can malicious nodes actually do?

- No (faithfully) PVF execution.
<!-- .element: class="fragment" -->
- Manipulate messages
<!-- .element: class="fragment" -->

Note:

Quick recap: What harm can a malicious validator actually do? What do we need to
worry about?

Not properly executing the block, providing results that don't adhere to the
rules of the PVF. Such a block would likely be not accepted by other parachain
nodes, but light clients might get fooled and more importantly other parachains
can get fooled with manipulated messages.

---

## Catch Bad Guys

- and punish them <!-- when caught -->
<!-- .element: class="fragment" -->
- gamblers ruin
<!-- .element: class="fragment" -->

Note:

- Eventually the system can be broken, but if attempts result in loss of
significant funds any realistic attacker will go go bankrupt way before.
- Purpose of backing checkers: Get skin in the game - collators are external.

---

## Idea

- Validators get skin in the game (backing)
<!-- .element: class="fragment" -->
- Check the checkers (approvals)
<!-- .element: class="fragment" -->
- Punish (disputes)
<!-- .element: class="fragment" -->

Note:

How: Validators need to be known in advance so collator nodes can connect. We
need to be able to check the checkers.

---

## Challenges

- Unknown approval checkers
<!-- .element: class="fragment" -->
- Data availability
<!-- .element: class="fragment" -->

Note:

- Approval checkers must not be known in advance (VRF).
- Data (PoVs) must be ensured to be available.
